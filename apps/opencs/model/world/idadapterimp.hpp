#ifndef CSM_WOLRD_IDADAPTERIMP_H
#define CSM_WOLRD_IDADAPTERIMP_H

#include <QVariant>

#include <components/esm/loadpgrd.hpp>
#include <components/esm/loadregn.hpp>

#include "idadapter.hpp"
#include "nestedtablewrapper.hpp"

namespace CSMWorld
{
    template<typename ESXRecordT>
    class PathgridPointListAdapter : public NestedIdAdapter<ESXRecordT>
    {
    public:
        PathgridPointListAdapter () {}

        virtual void addNestedRow(Record<ESXRecordT>& record, int position) const
        {
            ESXRecordT pathgrid = record.get();

            ESM::Pathgrid::PointList& points = pathgrid.mPoints;

            // blank row
            ESM::Pathgrid::Point point;
            point.mX = 0;
            point.mY = 0;
            point.mZ = 0;
            point.mAutogenerated = 0;
            point.mConnectionNum = 0;
            point.mUnknown = 0;

            // inserting a point should trigger re-indexing of the edges
            //
            // FIXME: undo does not restore edges table view
            // FIXME: does not auto refresh edges table view
            std::vector<ESM::Pathgrid::Edge>::iterator iter = pathgrid.mEdges.begin();
            for (;iter != pathgrid.mEdges.end(); ++iter)
            {
                if ((*iter).mV0 >= position)
                    (*iter).mV0++;
                if ((*iter).mV1 >= position)
                    (*iter).mV1++;
            }

            points.insert(points.begin()+position, point);
            pathgrid.mData.mS2 += 1; // increment the number of points

            record.setModified (pathgrid);
        }

        virtual void removeNestedRow(Record<ESXRecordT>& record, int rowToRemove) const
        {
            ESXRecordT pathgrid = record.get();

            ESM::Pathgrid::PointList& points = pathgrid.mPoints;

            if (rowToRemove < 0 || rowToRemove >= static_cast<int> (points.size()))
                throw std::runtime_error ("index out of range");

            // deleting a point should trigger re-indexing of the edges
            // dangling edges are not allowed and hence removed
            //
            // FIXME: undo does not restore edges table view
            // FIXME: does not auto refresh edges table view
            std::vector<ESM::Pathgrid::Edge>::iterator iter = pathgrid.mEdges.begin();
            for (; iter != pathgrid.mEdges.end();)
            {
                if (((*iter).mV0 == rowToRemove) || ((*iter).mV1 == rowToRemove))
                    iter = pathgrid.mEdges.erase(iter);
                else
                {
                    if ((*iter).mV0 > rowToRemove)
                        (*iter).mV0--;

                    if ((*iter).mV1 > rowToRemove)
                        (*iter).mV1--;

                    ++iter;
                }
            }
            points.erase(points.begin()+rowToRemove);
            pathgrid.mData.mS2 -= 1; // decrement the number of points

            record.setModified (pathgrid);
        }

        struct PathgridPointsWrap : public NestedTableWrapperBase
        {
            ESM::Pathgrid mRecord;

            PathgridPointsWrap(ESM::Pathgrid pathgrid)
                : mRecord(pathgrid) {}

            virtual ~PathgridPointsWrap() {}

            virtual int size() const
            {
                return mRecord.mPoints.size(); // used in IdTree::setNestedTable()
            }
        };

        virtual void setNestedTable(Record<ESXRecordT>& record, const NestedTableWrapperBase& nestedTable) const
        {
            record.get().mPoints =
                static_cast<const PathgridPointsWrap &>(nestedTable).mRecord.mPoints;
            record.get().mData.mS2 =
                static_cast<const PathgridPointsWrap &>(nestedTable).mRecord.mData.mS2;
            // also update edges in case points were added/removed
            record.get().mEdges =
                static_cast<const PathgridPointsWrap &>(nestedTable).mRecord.mEdges;
        }

        virtual NestedTableWrapperBase* nestedTable(const Record<ESXRecordT>& record) const
        {
            // deleted by dtor of NestedTableStoring
            return new PathgridPointsWrap(record.get());
        }

        virtual QVariant getNestedData(const Record<ESXRecordT>& record, int subRowIndex, int subColIndex) const
        {
            ESM::Pathgrid::Point point = record.get().mPoints[subRowIndex];
            switch (subColIndex)
            {
                case 0: return subRowIndex;
                case 1: return point.mX;
                case 2: return point.mY;
                case 3: return point.mZ;
                default: throw std::runtime_error("Pathgrid point subcolumn index out of range");
            }
        }

        virtual void setNestedData(Record<ESXRecordT>& record, const QVariant& value,
                                    int subRowIndex, int subColIndex) const
        {
            ESXRecordT pathgrid = record.get();
            ESM::Pathgrid::Point point = pathgrid.mPoints[subRowIndex];
            switch (subColIndex)
            {
                case 0: break;
                case 1: point.mX = value.toInt(); break;
                case 2: point.mY = value.toInt(); break;
                case 3: point.mZ = value.toInt(); break;
                default: throw std::runtime_error("Pathgrid point subcolumn index out of range");
            }

            pathgrid.mPoints[subRowIndex] = point;

            record.setModified (pathgrid);
        }

        virtual int getNestedColumnsCount(const Record<ESXRecordT>& record) const
        {
            return 4;
        }

        virtual int getNestedRowsCount(const Record<ESXRecordT>& record) const
        {
            return static_cast<int>(record.get().mPoints.size());
        }
    };

    template<typename ESXRecordT>
    class PathgridEdgeListAdapter : public NestedIdAdapter<ESXRecordT>
    {
    public:
        PathgridEdgeListAdapter () {}

        // FIXME: seems to be auto-sorted in the dialog table display after insertion
        virtual void addNestedRow(Record<ESXRecordT>& record, int position) const
        {
            ESXRecordT pathgrid = record.get();

            ESM::Pathgrid::EdgeList& edges = pathgrid.mEdges;

            // blank row
            ESM::Pathgrid::Edge edge;
            edge.mV0 = 0;
            edge.mV1 = 0;

            // NOTE: inserting a blank edge does not really make sense, perhaps this should be a
            // logic_error exception
            //
            // Currently the code assumes that the end user to know what he/she is doing.
            // e.g. Edges come in pairs, from points a->b and b->a
            edges.insert(edges.begin()+position, edge);

            record.setModified (pathgrid);
        }

        virtual void removeNestedRow(Record<ESXRecordT>& record, int rowToRemove) const
        {
            ESXRecordT pathgrid = record.get();

            ESM::Pathgrid::EdgeList& edges = pathgrid.mEdges;

            if (rowToRemove < 0 || rowToRemove >= static_cast<int> (edges.size()))
                throw std::runtime_error ("index out of range");

            edges.erase(edges.begin()+rowToRemove);

            record.setModified (pathgrid);
        }

        virtual void setNestedTable(Record<ESXRecordT>& record, const NestedTableWrapperBase& nestedTable) const
        {
            record.get().mEdges =
                static_cast<const NestedTableWrapper<ESM::Pathgrid::EdgeList> &>(nestedTable).mNestedTable;
        }

        virtual NestedTableWrapperBase* nestedTable(const Record<ESXRecordT>& record) const
        {
            // deleted by dtor of NestedTableStoring
            return new NestedTableWrapper<ESM::Pathgrid::EdgeList>(record.get().mEdges);
        }

        virtual QVariant getNestedData(const Record<ESXRecordT>& record, int subRowIndex, int subColIndex) const
        {
            ESM::Pathgrid::Edge edge = record.get().mEdges[subRowIndex];
            switch (subColIndex)
            {
                case 0: return subRowIndex;
                case 1: return edge.mV0;
                case 2: return edge.mV1;
                default: throw std::runtime_error("Pathgrid edge subcolumn index out of range");
            }
        }

        // FIXME: detect duplicates in mEdges
        virtual void setNestedData(Record<ESXRecordT>& record, const QVariant& value,
                                    int subRowIndex, int subColIndex) const
        {
            ESXRecordT pathgrid = record.get();
            ESM::Pathgrid::Edge edge = pathgrid.mEdges[subRowIndex];
            switch (subColIndex)
            {
                case 0: break;
                case 1: edge.mV0 = value.toInt(); break;
                case 2: edge.mV1 = value.toInt(); break;
                default: throw std::runtime_error("Pathgrid edge subcolumn index out of range");
            }

            pathgrid.mEdges[subRowIndex] = edge;

            record.setModified (pathgrid);
        }

        virtual int getNestedColumnsCount(const Record<ESXRecordT>& record) const
        {
            return 3;
        }

        virtual int getNestedRowsCount(const Record<ESXRecordT>& record) const
        {
            return static_cast<int>(record.get().mEdges.size());
        }
    };

    template<typename ESXRecordT>
    class RegionSoundListAdapter : public NestedIdAdapter<ESXRecordT>
    {
    public:
        RegionSoundListAdapter () {}

        virtual void addNestedRow(Record<ESXRecordT>& record, int position) const
        {
            ESXRecordT region = record.get();

            std::vector<ESXRecordT::SoundRef>& soundList = region.mSoundList;

            // blank row
            ESXRecordT::SoundRef soundRef;
            soundRef.mSound.assign("");
            soundRef.mChance = 0;

            soundList.insert(soundList.begin()+position, soundRef);

            record.setModified (region);
        }

        virtual void removeNestedRow(Record<ESXRecordT>& record, int rowToRemove) const
        {
            ESXRecordT region = record.get();

            std::vector<ESXRecordT::SoundRef>& soundList = region.mSoundList;

            if (rowToRemove < 0 || rowToRemove >= static_cast<int> (soundList.size()))
                throw std::runtime_error ("index out of range");

            soundList.erase(soundList.begin()+rowToRemove);

            record.setModified (region);
        }

        virtual void setNestedTable(Record<ESXRecordT>& record, const NestedTableWrapperBase& nestedTable) const
        {
            record.get().mSoundList =
                static_cast<const NestedTableWrapper<std::vector<ESM::Region::SoundRef> >&>(nestedTable).mNestedTable;
        }

        virtual NestedTableWrapperBase* nestedTable(const Record<ESXRecordT>& record) const
        {
            // deleted by dtor of NestedTableStoring
            return new NestedTableWrapper<std::vector<ESM::Region::SoundRef> >(record.get().mSoundList);
        }

        virtual QVariant getNestedData(const Record<ESXRecordT>& record, int subRowIndex, int subColIndex) const
        {
            ESXRecordT::SoundRef soundRef = record.get().mSoundList[subRowIndex];
            switch (subColIndex)
            {
                case 0: return QString(soundRef.mSound.toString().c_str());
                case 1: return soundRef.mChance;
                default: throw std::runtime_error("Region sounds subcolumn index out of range");
            }
        }

        virtual void setNestedData(Record<ESXRecordT>& record, const QVariant& value,
                                    int subRowIndex, int subColIndex) const
        {
            ESXRecordT region = record.get();
            ESXRecordT::SoundRef soundRef = region.mSoundList[subRowIndex];
            switch (subColIndex)
            {
                case 0: soundRef.mSound.assign(value.toString().toUtf8().constData()); break;
                case 1: soundRef.mChance = static_cast<unsigned char>(value.toInt()); break;
                default: throw std::runtime_error("Region sounds subcolumn index out of range");
            }

            region.mSoundList[subRowIndex] = soundRef;

            record.setModified (region);
        }

        virtual int getNestedColumnsCount(const Record<ESXRecordT>& record) const
        {
            return 2;
        }

        virtual int getNestedRowsCount(const Record<ESXRecordT>& record) const
        {
            return static_cast<int>(record.get().mSoundList.size());
        }
    };
}

#endif // CSM_WOLRD_IDADAPTERIMP_H
