/*               //This is old
	if (pieces > 1){             //pieces > 1
		MeshPtr justChest = MeshManager::getSingleton().createManual("justchest", group, NIFLoader::getSingletonPtr());
		Ogre::AxisAlignedBox bounds = resize->getBounds();
		Ogre::Vector3 width2 = bounds.getCorner(bounds.NEAR_RIGHT_BOTTOM) - bounds.getCorner(bounds.NEAR_LEFT_BOTTOM);
		Ogre::Vector3 depth2 = (bounds.getCorner(bounds.FAR_LEFT_BOTTOM) - bounds.getCorner(bounds.NEAR_LEFT_BOTTOM));
		Ogre::Vector3 height2 = bounds.getCorner(bounds.NEAR_LEFT_TOP) - bounds.getCorner(bounds.NEAR_LEFT_BOTTOM);
		cout << "Width:" << width2; cout << "Height:" << height2; cout << "Depth:" << depth2;
		/*int width = bounds.getMaximum().x - bounds.getMinimum().x;
		int height = bounds.getMaximum().y - bounds.getMinimum().y;
		int depth = bounds.getMaximum().z - bounds.getMinimum().z;
		int xinc = width / pieces;
		int yinc = height / pieces;
		int zinc = depth / pieces;
		int xmincorner = bounds.getMinimum().x + xinc*pieceIndex;
		int ymincorner = bounds.getMinimum().y + yinc*pieceIndex;
		int zmincorner = bounds.getMinimum().z + xinc*pieceIndex;*/
		//Ogre::Vector3 bottom_left = bounds.getCorner(bounds.NEAR_LEFT_BOTTOM) + (width2 / pieces) * pieceIndex;   //width2
		//Ogre::Vector3 top_right = bottom_left + (width2 / pieces) + height2 + depth2;
		//Ogre::AxisAlignedBox set = AxisAlignedBox ( Ogre::Vector3(xmincorner, bounds.getMinimum().y, bounds.getMinimum().z), Ogre::Vector3(xmincorner + xinc, bounds.getMaximum().y, bounds.getMaximum().z));
		//Ogre::AxisAlignedBox set = bounds;//AxisAlignedBox(bottom_left, top_right);
		//bounds.setMinimumX(xmincorner);
		//bounds.setMaximumX(xmincorner + xinc);
		//bounds.setMinimumY(ymincorner);
		//bounds.setMaximumY(ymincorner + yinc);
		//bounds.setMinimumZ(zmincorner);
		//bounds.setMaximumZ(zmincorner + zinc);
		//bounds.setMinimumY(bounds.getMinimum().y);
		//bounds.setMaximumY( bounds.getMaximum().y;
		//resize->_setBounds(set, true);
		//resize->reload();
	
	//Ogre::Mesh::SubMeshIterator subMeshIterator = resize->getSubMeshIterator();
	/*Ogre::Vector3* point;
	 Ogre::SubMesh* subMesh;



	 size_t vertex_count = 0;
	 Vector3* vertices;
    size_t index_count = 0; 
	unsigned* indices;
     Vector3 position = Vector3::ZERO;
     Quaternion orient = Quaternion::IDENTITY;
	 Vector3 scale = Vector3::UNIT_SCALE;


	// int vertex_count = 0;
  //int index_count = 0;
 
    bool added_shared = false;
    size_t current_offset = vertex_count;
    size_t shared_offset = vertex_count;
    size_t next_offset = vertex_count;
    size_t index_offset = index_count;
    size_t prev_vert = vertex_count;
    size_t prev_ind = index_count;
	// Calculate how many vertices and indices we're going to need
	/*
	std::cout <<"FIRST CYCLE\n";
    for(int i = 0;i < resize->getNumSubMeshes();i++)
    {
		std::cout<< "WEHAVEMESHES\n";
        SubMesh* submesh = resize->getSubMesh(i);
 
        // We only need to add the shared vertices once
        if(submesh->useSharedVertices)
        {
            if(!added_shared)
            {
                VertexData* vertex_data = resize->sharedVertexData;
                vertex_count += vertex_data->vertexCount;
                added_shared = true;
            }
        }
        else
        {
            VertexData* vertex_data = submesh->vertexData;
            vertex_count += vertex_data->vertexCount;
        }
 
        // Add the indices
        Ogre::IndexData* index_data = submesh->indexData;
        index_count += index_data->indexCount;
    }

   */
//	 Vector3* vertices;
	  // Allocate space for the vertices and indices
    /*vertices = new Vector3[vertex_count];
    indices = new unsigned[index_count];
	
	int meshcounter = 0;
    added_shared = false;
	std::cout <<"SECOND CYCLE: " << resize->getNumSubMeshes() << "\n";
    // Run through the submeshes again, adding the data into the arrays
	int i;
    for(i = 0;i < resize->getNumSubMeshes();i++)
    {
		
        SubMesh* submesh = resize->getSubMesh(i);
 
        Ogre::VertexData* vertex_data = submesh->useSharedVertices ? resize->sharedVertexData : submesh->vertexData;
		/*
        if((!submesh->useSharedVertices)||(submesh->useSharedVertices && !added_shared))
        {
            if(submesh->useSharedVertices)
            {
                added_shared = true;
                shared_offset = current_offset;
            }
 
            const Ogre::VertexElement* posElem = vertex_data->vertexDeclaration->findElementBySemantic(Ogre::VES_POSITION);
            Ogre::HardwareVertexBufferSharedPtr vbuf = vertex_data->vertexBufferBinding->getBuffer(posElem->getSource());
            unsigned char* vertex = static_cast<unsigned char*>(vbuf->lock(Ogre::HardwareBuffer::HBL_NORMAL));
            Ogre::Real* pReal;
			
			bool onepointexists = true;
			Vector3 lastpoint;
            for(size_t j = 0; j < vertex_data->vertexCount; ++j, vertex += vbuf->getVertexSize())
            {
                posElem->baseVertexPointerToElement(vertex, &pReal);
 
                Vector3 pt;
                pt.x = (*(pReal++));
                pt.y = (*(pReal++));
                pt.z = (*(pReal++));
				//cout << "X:" << pt.x << "Y:" <<pt.y << "Z:" <<pt.z << "\n";
				//cout << "Boxmin:" << set.getMinimum() <<" Boxmax:" <<set.getMaximum() <<"\n";
				//if(set.intersects(pt))
					//onepointexists = true;
				 if(!set.intersects(pt))
				{
					pt = lastpoint;
					//*pReal = pt.x;
					//*(pReal+1) = pt.y;
					//*(pReal+2) = pt.z;
					//vertex

				 }
				 else
					 lastpoint = pt;
				 
              
                pt = (orient * (pt * scale)) + position;
				if(!set.intersects(pt))
					onepointexists = false;
 
                vertices[current_offset + j].x = pt.x;
                vertices[current_offset + j].y = pt.y;
                vertices[current_offset + j].z = pt.z;
				
            }
			  /*if(true)
				{
					std::cout<< "Wearegoingtodelete"<< submesh->getMaterialName() << "\n";
					
					if(meshcounter <= 2)
						resize->destroySubMesh(i); 
					else if(meshcounter > 3 && meshcounter < 7)
						resize->destroySubMesh(i); 
					//submesh->setMaterialName("BaseWhiteNoLighting");   //red
					//submesh->updateMaterialUsingTextureAliases();
					//resize->
					meshcounter++;
					//delete submesh;
					//reakb;
				}*/
		/*
            vbuf->unlock();
            next_offset += vertex_data->vertexCount;
        }
 
        Ogre::IndexData* index_data = submesh->indexData;
 
        size_t numTris = index_data->indexCount / 3;
        unsigned short* pShort;
        unsigned int* pInt;
        Ogre::HardwareIndexBufferSharedPtr ibuf = index_data->indexBuffer;
        bool use32bitindexes = (ibuf->getType() == Ogre::HardwareIndexBuffer::IT_32BIT);
        if (use32bitindexes) pInt = static_cast<unsigned int*>(ibuf->lock(Ogre::HardwareBuffer::HBL_READ_ONLY));
        else pShort = static_cast<unsigned short*>(ibuf->lock(Ogre::HardwareBuffer::HBL_READ_ONLY));
 
        for(size_t k = 0; k < numTris; ++k)
        {
            size_t offset = (submesh->useSharedVertices)?shared_offset:current_offset;
 
            unsigned int vindex = use32bitindexes? *pInt++ : *pShort++;
            indices[index_offset + 0] = vindex + offset;
            vindex = use32bitindexes? *pInt++ : *pShort++;
            indices[index_offset + 1] = vindex + offset;
            vindex = use32bitindexes? *pInt++ : *pShort++;
            indices[index_offset + 2] = vindex + offset;
 
            index_offset += 3;
        }
        ibuf->unlock();
        current_offset = next_offset;*/
		//if (i == 3)                        //i!=3         i!=5
		//{
			//cout << "RETURNINGJUST\n";
			//SubMesh* test = 
			//test = resize->getSubMesh(i);
			//	cout << "s:" << shape << "\n";
    //NiTriShapeData *data = shape->data.getPtr();
   // SubMesh *sub = justChest->createSubMesh(name + "2"); 
	//sub = resize->getSubMesh(i);

   // int nextBuf = 0;

    // This function is just one long stream of Ogre-barf, but it works
    // great.

    // Add vertices
    //int numVerts = data->vertices.length / 3;
    //sub->vertexData = new VertexData();
    //sub->vertexData->vertexCount = numVerts;
   
			//justChest->load();
			//return resize;
		//}
		// 0   hand thumb
		// 1    hand thumb                                no chest on dunmer
    //}
	 //resize->destroySubMesh(1);
     /* while (subMeshIterator.hasMoreElements())
	  {
		  resize->getNum
		  //resize->d
		 std::cout << "CHEST";
		subMesh = subMeshIterator.getNext();*/
		 //std::vector<Vector3>::type test = 
		 //std::vector<Ogre::Vector3>::iterator fileIter = subMesh->extremityPoints.begin();
		 
			  //std::vector<Ogre::Vector3>::type test = subMesh->extremityPoints;
		//void* pData = subMesh->vertexData->vertexBufferBinding->getBuffer(1)->lock(0, 1000, HardwareBuffer::HBL_DISCARD);

		
		// if(set.contains( subMesh->vertexData->vertexStart))
		//delete subMesh;
		  //subMeshIterator.getNext();
		  //delete[] subMesh;
		  //subMesh->extremityPoints.clear();
		  //subMesh->mLodFaceList.clear();
		  //resize->destroySubMesh(subMesh->indexData->indexStart);
		  //resize->destroySubMesh(subMesh->indexData->);
		  //subMesh->
		  //std::cout << "THIS" << subMesh;
	  ///}
	  //subMesh->vertexData->vertexBufferBinding->getBuffer(0)->readData(subMesh->vertexData->vertexStart, sizeof Ogre::Vector3, point); 


	
	//boost::filesystem::directory_iterator dir_iter(dir), dir_end;
	
	//return resize;
